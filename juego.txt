juego de conseguir un dominio ("pintar casillas")
mapa/tablero (p ej: 50x50)
2-4 de momento jugadores
10-15 unidades/jugador
num maximo de unidades y num minimo de unidades
si el min es 5 y se muere tu quinta, reaparece en un lugar de tu zona
cada (por ejemplo) 3 rondas reaparecen unidades hasta llegar a un numero dado

las zonas se capturan saliendo de tu zona y dibujando un rectangulo

........  ........ ........
..rrrr..  ..rrrr.. ..rrrr..
..rrrr..  ..rrrr.. ..rrrr..
..rrrr..  ..rrrr.. ..rrrr..
........  ..d..d.. ..rrrr..
........  ..d..d.. ..rrrr..
........  ..dddd.. ..rrrr..
........  ........ ........

por lo menos uno de los lados de la zona nueva debe ser dibujo.

Máximo de casillas pintables de golpe: evita pintar todo el mapa
	si se sobrepasa, se pintan máximo casillas y se eligen las
	más cercanas al dominio del jugador

dentro de mi zona:
mis unidades se mueven y atacan en diagonal
aparecen cosas (burbujas?) que puedes atacar y petar para puntos
	las burbujas se mueven cada 2 o 3 turnos en cualquier dirección
	si un enemigo las ataca, dentro de x turnos explotan generando
	 .
	...
	 .
	 y reaparece una unidad de su equipo en su zona (si u < umax)
	 
energía:
cada ronda pasada en una casilla de mi zona +1 puntos
cada ronda pasada en una casilla neutral 0 puntos
cada ronda pasada en una casilla enemiga -1 puntos

valores minimo y maximo (maximo?)

la energía ayuda a decidir las batallas, (al luchar se pierde energía aunque ganes?)
moverse a una casilla con una unidad la ataca; si ganas, te mueves a la casilla.
atacar a una casilla ataca a la unidad que está ahí. Si se ha movido previamente y sigue
en rango, la atacas igualmente. No te mueves.

bonus:
el mapa tiene bonus que sirven para mejorar unidades
un equipo solo puede mejorar una unidad a la vez (por ejemplo)

idea: una unidad con bonus no pierde energía por estar en zona enemiga
	consigue también la energía máxima?

habilidad: una unidad mejorada hace aparecer un NxN a su alrededor que
sobrepinta lo que hubiese debajo (supongamos que no elimina los trazos/dibujos) y 
encierra la zona: los enemigos no pueden ni entrar ni salir. 

conflictos de habilidades:
	1: si se tiran el mismo turno empatan, ocurre nada
	2: si se tiran el mismo turno empatan, pintan mediomedio y anulan barrera
	3: si se tira después sobrepinta y anula la habilidad anterior
	4: si se tira después no hace nada
	5: si se tira después anula la habilidad anterior
	6: si se tira después pinta mediomedio y anula barrera
m2


clases

Game
Board
Player
Order

Las rondas son de Board
Las órdenes son de Order
Player y Border acceden a Order

4 clases principales: Game, Board, Order y Player

Game es el macroprograma, se encarga de leer datos, ejecutar códigos de jugadores y pasar ronda
Board es el tablero de juego, se encarga de ejecutar las órdenes y cambiar el tablero
Order guarda las órdenes de todos los jugadores
Player es la clase que necesitas para meter el código de cada jugador

1-game registra jugadores y lee config
2-game inicializa partida ronda = 0
3-game ejecuta los códigos de los jugadores
4-el tablero accede a las órdenes y las ejecuta
5-el tablero actualiza cosas que pasan entre rondas
6-output del estado de la ronda
7-pasar ronda
8-si no se ha acabado la partida, vuelve a 3



encierras la zona a pintar con muro (mientras tanto, calculas caja contenedora)
copias el trozo de la caja contenedora a una matriz nueva de ese tamaño

recorres i,j de la copia para ver si se puede pintar. Cada vez que pintas o lo intentas usas un color nuevo y al final te guardas si ha servido o no

copias todo en la matriz original otra vez con las casillas bien pintadas

recorres i,j de la caja contenedora y
	si está pintada y tiene casillas no pintadas por mí a un lado (que no son dibujo) les pone frontera
	si está pintada y no tiene casillas adyacentes sin pintar, les quita frontera





cosas que hay que hacer para poder programar un bot

poder dar los 3 tipos de orden
que los respawns funcionen
que salgan blobs
que salgan bonus
que la energía se gane y se pierda como toca


para que vayan los respawns

al final de cada ronda:

guarda que posiciones son de quien
incrementa timers si no valen sus valores máximos

	respawn()
	lo que hace esta operacion es
	-si alguno tiene como valor ROUNDS_PER_RESPAWN,
		-intenta spawnear una unidad nueva
			-recopila todas las posiciones válidas
			-selecciona un número random entre 0 y posiciones.size()-1
		-si se ha podido, contador a 0 y borrar la posicion del conjunto
		-si no, deja el contador sin tocar

	spawn_blobs() se puede juntar con respawn unit probablemente


	si toca bonus, selecciona posiciones random y cuando tengas una sin ocupar ponlo ahí













